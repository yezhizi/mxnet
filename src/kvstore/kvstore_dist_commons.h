#ifndef kvstore_dist_commons_h
#define kvstore_dist_commons_h

#include <mxnet/c_api.h>
#include <mxnet/kvstore.h>
#include <ps/ps.h>
#include <queue>
#include <string>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <functional>
#include <future>
#include <vector>

namespace mxnet {
namespace kvstore {

enum class ControllerCommand {
  kNotifyPreparationFinished = 11,
  kNodeScaleAnounce = 12,
  kTimestampUpdate = 13,
};

// maintain same order in frontend.
enum class CommandType {
  kController,
  kSetMultiPrecision,
  kStopServer,
  kSyncMode,
  kSetGradientCompression,
  kSetProfilerParams
};

enum class RequestType {
  kDefaultPushPull,
  kRowSparsePushPull,
  kCompressedPushPull,
  kParamtersMigration
};

struct DataHandleType {
  RequestType requestType;
  int dtype;
};

/*!
 * Uses Cantor pairing function to generate a unique number given two numbers.
 * This number can also be inverted to find the unique pair whose Cantor value is this number.
 * Ref: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function
 * \param requestType RequestType
 * \param dtype integer
 * \return Cantor value of arguments
 */
static int GetCommandType(RequestType requestType, int d) {
  int m = static_cast<int>(requestType);
  return (((m + d) * (m + d + 1)) / 2) + d;
}

/*!
 * Unpairs Cantor value and finds the two integers used to pair.
 * Then returns DataHandleType object with those numbers.
 * \param cmd DataHandleCommand generated by GetCommandType function
 * \return DataHandleType
 */
static DataHandleType DepairDataHandleType(int cmd) {
  int w = std::floor((std::sqrt(8 * cmd + 1) - 1) / 2);
  int t = ((w * w) + w) / 2;
  int y = cmd - t;
  int x = w - y;
  CHECK_GE(x, 0);
  CHECK_GE(y, 0);
  DataHandleType type;
  type.requestType = static_cast<RequestType>(x);
  type.dtype = y;
  return type;
}

static bool isControllerCommand(int head) {
  return head > 10;
}

class NodeScalingInfo {
 public:
  NodeScalingInfo() : is_worker_(false), num_ready_nodes_(0), future_timestamp_(0){};

  ~NodeScalingInfo() = default;

  void Clear() {
    nodes_.clear();
    is_worker_ = false;
    num_ready_nodes_ = 0;
    future_timestamp_ = 0;
  }

  int GetFutureTimestamp() {
    return future_timestamp_;
  }
  const std::vector<int>& GetNodes() const {
    return nodes_;
  }

  const bool IsWorker() const {
    return is_worker_;
  }

  void Decode(const std::string& str) {
    std::istringstream is(str);
    std::string type;
    is >> type;
    is_worker_ = type == "w";
    is >> future_timestamp_;
    int node;
    while (is >> node) {
      nodes_.push_back(node);
    }
  }
  std::string DebugStrNodes() {
    std::string ret;
    for (auto node : nodes_) {
      ret += std::to_string(node);
      ret += ",";
    }
    return ret;
  }

  std::string Encode() const {
    std::string ret;
    // w 10 8,9,10  ==>  worker timestamp=10 nodes=8,9,10
    ret += is_worker_ ? "w " : "s ";
    ret += std::to_string(future_timestamp_);
    ret += " ";
    for (auto node : nodes_) {
      ret += std::to_string(node);
      ret += ",";
    }
    return ret;
  }

 private:
  void RegisterNode(bool is_worker, int node_id) {
    if (!nodes_.empty()) {
      CHECK(is_worker && is_worker_) << "Not Support different type of node scalling";
    }
    nodes_.push_back(node_id);
    is_worker_ = is_worker;
  }

  bool NodeReady(int node_id) {
    if (std::find(nodes_.begin(), nodes_.end(), node_id) != nodes_.end()) {
      num_ready_nodes_++;
      if (num_ready_nodes_ == nodes_.size())
        return true;
    } else {
      LOG(WARNING) << "NodeReady Recieve A unregister Node id: " << node_id;
    }
    return false;
  }
  void setFutureTimestamp(int future_timestamp) {
    this->future_timestamp_ = future_timestamp;
  }

  friend class KVStoreDistController;

  std::vector<int> nodes_;
  bool is_worker_;
  int num_ready_nodes_;
  int future_timestamp_;
};

/**
 * \brief executor runs a function using the thread called \ref Start
 */
class Executor {
 public:
  /**
   * \brief start the executor
   */
  void Start() {
    std::unique_lock<std::mutex> lk(mu_);
    while (true) {
      cond_.wait(lk, [this] { return !queue_.empty(); });
      Block blk = std::move(queue_.front());
      queue_.pop();
      lk.unlock();

      if (blk.f) {
        blk.f();
        blk.p->set_value();
      } else {
        blk.p->set_value();
        break;
      }
      lk.lock();
    }
  }

  /**
   * \brief function
   */
  typedef std::function<void()> Func;

  /**
   * \brief let the thread called \ref Start to exec a function. threadsafe
   */
  void Exec(const Func& func) {
    Block blk(func);
    auto fut = blk.p->get_future();
    {
      std::lock_guard<std::mutex> lk(mu_);
      queue_.push(std::move(blk));
      cond_.notify_one();
    }
    fut.wait();
  }

  /**
   * \brief stop the thread, threadsafe
   */
  void Stop() {
    Exec(Func());
  }

 private:
  struct Block {
    explicit Block(const Func& func) : f(func), p(std::make_shared<std::promise<void>>()) {}
    Func f;
    std::shared_ptr<std::promise<void>> p;
  };
  std::queue<Block> queue_;
  std::mutex mu_;
  std::condition_variable cond_;
};

class RecvedParamsStore {
 public:
  RecvedParamsStore() : begin_timestamp_(0) {}

  NDArray& WaitKey(int key) {
    std::unique_lock<std::mutex> lock(mu_);
    cond_.wait(lock, [this, key] { return recvdstore_.count(key); });
    return recvdstore_[key];
  }

  void Store(int key, const NDArray& value, int timestamp = 0) {
    std::lock_guard<std::mutex> lock(mu_);
    // store recvd paramers
    if (!recvdstore_.count(key)) {
      auto& recvd = recvdstore_[key];
      recvd = NDArray(value.shape(), value.ctx(), false, value.dtype());
      CopyFromTo(value, &recvd);
      recvd.WaitToRead();
    } else {
      LOG(WARNING) << "Key:" << key << " is already in the store";
    }
    // set timestamp
    if (begin_timestamp_ == 0) {
      CHECK_NE(timestamp, 0) << "Timestamp is not set";
      begin_timestamp_ = timestamp;
    } else if (timestamp != 0) {
      CHECK_EQ(begin_timestamp_, timestamp) << "Timestamp is not consistent";
    }
    cond_.notify_all();
  }

  void Clear(int key) {
    std::lock_guard<std::mutex> lock(mu_);
    CHECK(recvdstore_.count(key)) << "Key:" << key << " is not in the store";
    recvdstore_.erase(key);
  }

  void ClearAll() {
    std::lock_guard<std::mutex> lock(mu_);
    recvdstore_.clear();
  }

  int GetBeginTimeStamp() {
    std::lock_guard<std::mutex> lock(mu_);
    return begin_timestamp_;
  }

 private:
  int begin_timestamp_;
  std::unordered_map<int, NDArray> recvdstore_;
  std::mutex mu_;
  std::condition_variable cond_;
};

}  // namespace kvstore
}  // namespace mxnet

#endif  // kvstore_dist_commons_h